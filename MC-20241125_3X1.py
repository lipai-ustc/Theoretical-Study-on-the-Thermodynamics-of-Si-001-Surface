import numpy as np
import random
from scipy import interpolate
import sys
T = float(sys.argv[1])
P_H2 = float(sys.argv[2])
# ������������������������������������������������������������������������������������������������������������������������������������������������������������������
temperatures = np.arange(100, 1601, 100)

kB =  8.617333262145e-5  # ������������������������������������������������������������������������������������������������������������������������������������������������������������������, unit in eV/K
#T =   1300  # ������������������������������������������������������, unit in K, T>0
#P_H2= 1.0   # unit in Bar
P0  = 1     # unit in Bar

DFT_H2=-6.904   # recalculate and replace this value

# below is for calculating chemical potential of H, which is named as u_H
Tx=np.array([0,100,200,250,298.15,300,350,400,450,500,600,700,800,900,1000,
             1100,1200,1300,1400,1500,1600,1700,1800,1900])
# h_H2 and S_H2 can be get from NIST-JANAF table: https://zhuanlan.zhihu.com/p/38504303X4
h_H2=np.array([-8.467,-5.468,-2.774,-1.378,0,0.053,1.502,2.959,4.420,
               5.882,8.811,11.749,14.702,17.676,20.680,23.719,26.797,29.918,
               33.082,36.290,39.541,42.835,46.169,49.541])   # unit in kJ/mol
h_H2=(h_H2+8.467)*0.01036410  # unit in eV
f_h_H2=interpolate.interp1d(Tx,h_H2,kind='cubic')#������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������

S_H2=np.array([0,100.727,119.412,125.640,130.680,130.858,135.325,139.216,
               142.656,145.737,151.077,155.606,159.548,163.051,166.216,169.112,171.790,
               174.288,176.633,178.846,180.944,182.940,184.846,186.669])  # unit in J/mol/K
S_H2=S_H2*0.01036410*1e-3  # unit in eV/K
f_S_H2=interpolate.interp1d(Tx,S_H2,kind='cubic')

# define u_H as a function of Temperature T and H2 pressure P_H2
G_H2 = DFT_H2 + f_h_H2(T) - T*f_S_H2(T) + kB*T*np.log(P_H2/P0)
u_H  = G_H2/2
print("T,P_H2,DFT_H2, f_h_H2,T*f_S_H2,kB*T*np.log(P/P0)")
print(T,P_H2,DFT_H2, f_h_H2(T),T*f_S_H2(T),kB*T*np.log(P_H2/P0))
print("u_H: %.3f"%u_H)

# E2H E0H and ESI ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������E0H=0, ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
E0H = 0
E2H = -4.5560780
ESI = -8.2225600
EOLOR = 0
E2H2H = 0
ESISI = 0 
E2HOL = 0.007228487   # 2H ���������������������������0H ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
E2H2HM = 0.035233364  #
E2HOLM = 0.042401988
EOLORM = 0.035377502 
ESI2H = 0.004674159
ESIOL = 0.017557446
ESILR = 0.098666392
Edmm = -0.029965124 *2 # ?

ij_max=18      # ������������������������������������������������������������������������������������������������������������
steps = 100000  # MC ������������������������������������������������������������������������������������������������������������

def wrap(index):               # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    if index >= ij_max:
        return index % ij_max  # ������������������������������������������������������ ij_max ���������������������������������������������������������������������������������������������������������������������������������������
    elif index < 0:
        return (index + ij_max) % ij_max  # ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    else:
        return index

def generate_xp(x):            # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ x ��������������������������� x'
    xp = x
    while abs(x - xp) < 4:     # ������������������������������������������������������ i ��������������������������� xp ������������������������������������������������������������������������������������������������������������������������������������������������������������������
        xp = random.randint(0, ij_max-1)
    return xp

def print_SMatrix(Matrix):
    for j in range(ij_max):    
        for i in range(ij_max):
            print(f"%3d "%Matrix[i,j],end="") 
        print()          

def H_coverage(X):             # H������������������������������������������������������������������������������������������������������������������������������������������������������������������range in [0,2]
    H_num=0
    for i in range(ij_max):    
        for j in range(ij_max):    
            if X[i,j]==0:
                H_num+=2
            elif X[i,j]==1 or X[i,j]==-1:
                H_num+=1
    return H_num/ij_max/ij_max

# ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
vib_energy_matrix = {
    "monomer": np.array([0.48645348, 0.47719778, 0.45467208, 0.41920727, 0.37214952, 0.31479102,
                         0.24819566, 0.17322728, 0.09060052, 0.00091954, -0.09529608, -0.19759372,
                         -0.30557533, -0.41888829, -0.53721825, -0.66028348]),
    "dimer_H": np.array([0.27314835, 0.26650983, 0.24975773, 0.22318078, 0.18794009, 0.14512674,
                         0.09562228, 0.04012905, -0.02078363, -0.08664432, -0.15705537, -0.23167637,
                         -0.31021249, -0.39240587, -0.47802917, -0.56688055]),
    "dimer_O": np.array([0.05492426, 0.04758734, 0.03153517, 0.00823388, -0.02093751, -0.05497231,
                         -0.0931371, -0.13488213, -0.17978286, -0.22750274, -0.27776891, -0.33035602,
                         -0.38507491, -0.44176469, -0.50028683, -0.56052088]),
}

# ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
state_to_vib_energy = {
    0: "monomer",   # ������������������������������������������������������ 0: monomer
    1: "dimer_H",   # ������������������������������������������������������ 1: dimer_H (���������������������������)
   -1: "dimer_H",   # ������������������������������������������������������ -1: dimer_H (���������������������������)
   10: "dimer_O",   # ������������������������������������������������������ 10: dimer_O (���������������������������)
  -10: "dimer_O",   # ������������������������������������������������������ -10: dimer_O (���������������������������)
}

def get_vib_energy(state, T):
    # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    energy_key = state_to_vib_energy.get(state, None)
    if energy_key is None:
        return 0  # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ 0

    # ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    temp_index = np.abs(temperatures - T).argmin()
    
    # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    return vib_energy_matrix[energy_key][temp_index]

def calc_energy(X, i, j,T):      # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
  
    # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ wrap ������������������������������������������������������������������������������������������������������������
    up = wrap(j - 1)
    down = wrap(j + 1)
    left = wrap(i - 1)
    right = wrap(i + 1)
    left_2 = wrap(i - 2)
    right_2 = wrap(i + 2)

    # ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    state = X[i, j]
    # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    E_self = {1: E2H, -1: E2H, 0: ESI, 10: E0H, -10: E0H}.get(state, "not found")
    # ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    F_vib = get_vib_energy(state, T) # ��������������������������� vib_energy ������������������������������������������������������������������������������������������������������������ F_vib ���������������������������
    # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    interaction_energy={
        1: {1: E2H2H, -1: E2H2HM, 0: ESI2H, -10: E2HOLM, 10: E2HOL},
       -1: {1: E2H2HM, -1: E2H2H, 0: ESI2H, -10: E2HOL, 10: E2HOLM},
      -10: {10: EOLORM, -10: EOLOR, 0: ESIOL, -1: E2HOL, 1: E2HOLM},
       10: {10: EOLOR, -10: EOLORM, 0: ESIOL, 1: E2HOL, -1: E2HOLM},
        0: {10: ESIOL, -10: ESIOL, 0: ESISI, 1: ESI2H, -1: ESI2H}  }

    # ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    E_inter  = interaction_energy.get(X[i, j]).get(X[i, up])
    E_inter += interaction_energy.get(X[i, j]).get(X[i, down])

    # ������������������������������������������������������������������������������������������������������������������������������������������������������������������ 0���������������������������monomer���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    if X[i, j] == 0:
        # ������������������������������������������������������������������������������������������������������������ 0 ������������������������������������������������������������������������������������������������������������ ESILR
        if X[left, j] == 0:
            E_inter += ESILR
            if X[right,j] == -1:
                E_inter += Edmm
        # ������������������������������������������������������������������������������������������������������������ 0 ������������������������������������������������������������������������������������������������������������ ESILR
        if X[right, j] == 0:
            E_inter += ESILR
            if X[left,j] == 1:
                E_inter += Edmm

    return E_self + F_vib, E_inter

def total_energy(X, i_min, i_max, y,T):  # ������������������������������������������������������X[i_min-2,y-1]���������������������������X[i_max+3,y+2] ���������������������������������������������������������������������������������
    E_total_self = 0
    E_total_inter =0
    if i_min>=i_max:   raise Exception("error in total_energy!") 
    if i_max+3-(i_min-2)>=ij_max:
        ii_min=0
        ii_max=ij_max
    else:
        ii_min=i_min-2
        ii_max=i_max+3
    for i in range(ii_min,ii_max):  # ���������������������������������������������������������������������������������������������������������������������������������������wrap,���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
        for  j in range(y-1,y+2):     #������������������������������������������������������,���������������������������������������������������������������������������������������������������������������������������������������wrap
            (temp1,temp2) = calc_energy(X,wrap(i),wrap(j),T)  #���������������������������������������������������������������������������������wrap,������������������������������������������������������������������������������������������������������������calc_energy������������������������������������������������������wrap
            E_total_self  += temp1
            E_total_inter += temp2
    return E_total_self, E_total_inter

# ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
#######################################################
#
#      ������������������������������������������������������������������������������������������������������������S������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
#        -1   dimer left w. H
#         1   dimer right w. H
#         0   monomer w. H
#       -10   dimer left  w.o H
#        10   dimer right w.o H
#     
#      possible events:
#      event1  dimerH -> dimerO
#      event2  dimerO -> dimerH 
#      event3  dimerH -> 2 x monomer
#      event4  dimerO -> 2 x monomer
#      event5  2 x monomer -> dimerH 
#      event6  2 x monomer -> dimerO 
#      event7  dimer <-> monomer # ��������������������������������������������������������������������������������� dimerO <-> dimerH ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
#
#######################################################

S = np.zeros((ij_max,ij_max), dtype=int)  # ���������������������������������������������������������������������������������
# ��������������������������������� -1 ��� 1
for j in range(18):
    # 每行填充6对(-1, 1)和6个0
    for i in range(0, 18, 3):  # 每隔3列进行一次填充
        S[i, j] = -1
        S[i+1, j] = 1
        # j + 2 为 0，初始化时已经是0，所以不需要单独填充
    
# 打印结果查看
print_SMatrix(S)
initial_energy = calc_energy(S, 0, 0, T)
print(f"Initial energy at (0,0): {initial_energy}")


for step in range(steps):   # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
    St = np.copy(S)
    x = random.randint(0, ij_max-1)   # ������������������������������������������������������������������������������������������������������������i,j���������������������������������������������������������������������������������x,y
    y = random.randint(0, ij_max-1)   # ������������������������������������������������������i,j������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������

    if S[x,y]!=0:     # ������������������������������������������������������dimer     
        if random.choice([1,2])==1:  # event 1/2 :   dimer -> dimer   
            if S[x,y]==1:            # event1, right  # dimerH -> dimerO
                St[wrap(x-1),y]=-10  
                St[x,y]=10     
                dN_H=2                # Number difference of H atoms # init - final
            elif S[x,y]==-1:         # event1, left
                St[x,y]=-10     
                St[wrap(x+1),y]=10  
                dN_H=2                # Number difference of H atoms # init - final
            elif S[x,y]==10:         # event2, right  # dimerO -> dimerH
                St[wrap(x-1),y]=-1 
                St[x,y]=1
                dN_H=-2               # Number difference of H atoms # init - final
            elif S[x,y]==-10:        # event2, left
                St[x,y]=-1   
                St[wrap(x+1),y]=1
                dN_H=-2               # Number difference of H atoms # init - final
            else:   
                raise Exception("error in monte_carlo!")

            # calc i_min & i_max for energy calculation
            if S[x,y]<0:     
                i_min=x
                i_max=x+1  # do not wrap, to guarantee that i_min<i_max
            else: 
                i_min=x-1  # do not wrap, otherwise it might occur error in total_energy function.
                i_max=x

        else: # random.choice==2 # event 3/4 :      dimer -> 2*monomer
            if S[x,y]==1 or S[x,y]==-1:
                dN_H=-2                       # Number difference of H atoms # init - final
            elif abs(S[x,y])==10 or S[x,y]==-10:
                dN_H=-4                       # Number difference of H atoms # init - final
            xp = generate_xp(x)              # ���������������������������������������������������������������������������������x���������������������������������������������������������������������������������monomer���������������������������������������������������������������������������������x'
            if xp<x :                        # x'���������������������������������������������������������������������������������, x���������������������������������������������������������������������������������
                if S[x,y]>0:    i_max=x     # i_max���������������������������������������������������������������������������������dimer������������������������������������������������������,���������������������������������������������������������������������������������������������������������������������������������������
                else:            i_max=x+1   # i_max������������������������������������������������������wrap,������������������������������������������������������������������������������������������������������������total_energy���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
                if S[xp,y]>0:   i_min=xp+1  # i_min������������������������������������������������������������������������������������������������������������dimer������������������������������������������������������
                else:            i_min=xp    # i_min������������������������������������������������������������������������������������������������������������dimer������������������������������������������������������,������������������������������������������������������������������������������������������������������������monomer
                for ii in range(i_min+1,i_max):
                    St[ii,y]=S[ii-1,y]       # ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
            else:  # x���������������������������������������������������������������������������������, x'���������������������������������������������������������������������������������       # ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
                if S[x,y]<0:    i_min=x     # i_min���������������������������������������������������������������������������������dimer������������������������������������������������������,���������������������������������������������������������������������������������������������������������������������������������������
                else:            i_min=x-1   # i_min������������������������������������������������������wrap,������������������������������������������������������������������������������������������������������������total_energy��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������� 
                if S[xp,y]<0:   i_max=xp-1  # i_max������������������������������������������������������������������������������������������������������������dimer������������������������������������������������������ ���������������������������xp+1���������������������������������������������������������������������������������������������������������������������������������������
                else:            i_max=xp    # i_max������������������������������������������������������������������������������������������������������������dimer������������������������������������������������������,������������������������������������������������������������������������������������������������������������monomer 
                for ii in range(i_min+1,i_max):
                    St[ii,y]=S[ii+1,y]       # ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
            St[wrap(i_min),y]=0              # ���������������������������������������������������������������������������������monomer 
            St[wrap(i_max),y]=0              # ���������������������������������������������������������������������������������monomer 

    elif S[x,y]==0:   # ������������������������������������������������������monomer   # event 5/6
        monomer_list = []
        for i in range(ij_max):
            if S[i, y] == 0 and i!=x:  # ������������������������������������������������������ monomer ������������������������������������������������������
               monomer_list.append(i)
        if len(monomer_list)<1:        # monomer ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
            raise Exception("monomer_list error!") # btw, ij_max������������������������������������������������������������������������������������������������������������3���������������������������2���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������3*1������������������������������������������������������
        xp = random.choice(monomer_list)
        i_min=min(x,xp)
        i_max=max(x,xp)
        for i in range(i_min,i_max-1): # ������������������������������������������������������ ������������������������������������������������������������������������������������������������������������������������������������������������������������������wrap
            St[i,y]=St[i+1,y]
        if random.choice([1,2])==1:   # event 5
            St[i_max-1,y]=-1
            St[i_max,y]=1
            dN_H = 2 
        else:                          # event 6
            St[i_max-1,y]=-10
            St[i_max,y]=10
            dN_H = 4
   
    (E1_self,E1_inter) = total_energy(S, i_min, i_max, y,T)  # initial state
    (E2_self,E2_inter) = total_energy(St,i_min, i_max, y,T)  # final state
    E1=E1_self+E1_inter
    E2=E2_self+E2_inter
    dE = E2 + u_H*dN_H - E1
    if abs(dE)>10:
        print("E1,E2,dE,dN_H:  %.3f %.3f %.3f %d"%(E1,E2,dE,dN_H))
        print("E1_self,E1_inter:  %.3f %.3f "%(E1_self,E1_inter))
        print("E2_self,E2_inter:  %.3f %.3f "%(E2_self,E2_inter))
        print("dE_self,dE_inter:  %.3f %.3f "%(E2_self-E1_self,E2_inter-E1_inter))
        print("i_min,i_max:  %d  %d"%(i_min,i_max))
        print("Step: %d"%step)
        print("S Matrix")
        print_SMatrix(S)
        print("St Matrix")
        print_SMatrix(St)
        print("diff")
        print_SMatrix(St-S)
        print(f"Energy difference too large: dE = {dE:.3f}")
        raise Exception("error in dE!")

    P = np.exp(-dE / (kB * T)) if dE>0 else 1   # ������������������������������������������������������������������������������������������������������������������������������������������������������������������P

    #print(f"Step {step}: E1 = {E1:.6f}, E2 = {E2:.6f}, dE = {dE:.6f}, P = {P:.6f}")
    if random.uniform(0, 1) < P :
        S = np.copy(St)                         # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ 
       # print("Accepted new state.")
    #else:
       # print("Rejected new state.")

    if step%(steps/10)==0:                      # event7��������������������������� ��������������������������������������������������������������������������������� monomer <-> dimer ������������������������������������������������������������������������������������������������������������,������������������������������������������������������dN_H=0
        St = np.copy(S)
        x = random.randint(0, ij_max-1)         # ������������������������������������������������������������������������������������������������������������i,j���������������������������������������������������������������������������������x,y
        y = random.randint(0, ij_max-1)         # ������������������������������������������������������i,j������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
        flag=False
        if random.choice([1,2])==1:             # ������������������������������������������������������������������������������������������������������������mono/dimer������������������������������������������������������
            if S[x,y]==0:                       # ���������������������������������������������������������������������������������monomer
                if S[wrap(x-1),y]>0:            # ���������������������������������������������������������������������������������dimer
                    flag=True
                    i_max=x
                    i_min=i_max-2               # i_min���������������������������i_max������������������������������������������������������������������������������������������������������������wrap
                    St[wrap(i_max),y]   = S[wrap(i_max-1),y]
                    St[wrap(i_max-1),y] = S[wrap(i_max-2),y]
                    St[wrap(i_max-2),y] = 0
            else:                               # ���������������������������������������������������������������������������������dimer
                if S[x,y]<0:                     
                    i_max=x+1                   # ���������������������������i_max������������������������������������������������������dimer������������������������������������������������������,������������������������������������������������������wrap
                if S[wrap(i_max-2),y]==0:       # ���������������������������������������������������������������������������������monomer
                    flag=True
                    i_min=i_max-2
                    St[wrap(i_max-2),y] = S[wrap(i_max-1),y]
                    St[wrap(i_max-1),y] = S[wrap(i_max),y]
                    St[wrap(i_max),y]   = 0
        else:                                   # ������������������������������������������������������������������������������������������������������������mono/dimer������������������������������������������������������
            if S[x,y]==0:                       # ���������������������������������������������������������������������������������monomer
                if S[wrap(x+1),y]<0:            # ���������������������������������������������������������������������������������dimer 
                    flag=True
                    i_min=x
                    i_max=i_min+2               # i_min���������������������������i_max������������������������������������������������������������������������������������������������������������wrap
                    St[wrap(i_min),y]   = S[wrap(i_min+1),y]
                    St[wrap(i_min+1),y] = S[wrap(i_min+2),y]
                    St[wrap(i_min+2),y] = 0
            else:                               # ���������������������������������������������������������������������������������dimer
                if S[x,y]>0:                     
                    i_min=x-1                   # ���������������������������i_max������������������������������������������������������dimer������������������������������������������������������,������������������������������������������������������wrap
                if S[wrap(i_min+2),y]==0:       # ���������������������������������������������������������������������������������monomer
                    flag=True
                    i_max=i_min+2               # i_min���������������������������i_max������������������������������������������������������������������������������������������������������������wrap
                    St[wrap(i_min+2),y]=S[wrap(i_min+1),y]
                    St[wrap(i_min+1),y]=S[wrap(i_min),y]
                    St[wrap(i_min),y]=0
        if flag:
            (E1_self,E1_inter) = total_energy(S, i_min, i_max, y, T)  # initial state
            (E2_self,E2_inter) = total_energy(St,i_min, i_max, y, T)  # final state
            E1=E1_self+E1_inter
            E2=E2_self+E2_inter
            dE = E2 - E1  # ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������dN_H=0
            if abs(dE)>2.5:
                print("E1,E2,dE:  %.3f %.3f %.3f"%(E1,E2,dE))
                raise Exception("error in dE!")
            P = np.exp(-dE / (kB * T)) if dE>0 else 1   # ������������������������������������������������������������������������������������������������������������������������������������������������������������������P
           # print(f"dE: {dE}, P: {P}")
            if random.uniform(0, 1) < P :
                S = np.copy(St)                         # ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ 
               # print("Exchange successfully!")

    if step%(steps/10)==0:
        print("step: %10d  H coverage: %.3f"%(step, H_coverage(S)))

# print final matrix
print("Final S state:")
print_SMatrix(S)

print("\nFinal H coverage: %.3f"%H_coverage(S))
